26)Виведення двохвимірного числового масиву
cout << "матриця виведення";
	cout << endl;
	for (int i(0);i < n;i++)
	{
		for (int j(0);j < n;j++)
		{
			cout << p1[i][j] << " ";//вивели рандомну матрицю
        }cout << endl;
27)Оголення структури.


1struct Name
2{
 3   type atrib;
 4   // решта елементів структури   
5} structVar1, structVar2, ...;
де,

struct – ключове слово, яке починає визначення структури
Name – ім'я структури
type – тип даних елемента структури
atrib – елемент структури
structVar1-2 – структурні змінні
Оголошення структури завжди повинно починатися з ключового слова struct.
 Не Обов'язково, щоб структура мала ім'я, але тоді така структура
 обов'язково повинна мати структурні змінні, оголошені між закриває
 фігурною дужкою і крапкою з комою, рядок 5. Обов'язково в оголошенні
 структури повинні бути присутніми фігурні скобочки, вони обрамляють 
тіло структури, в якому оголошуються її атрибути (елементи), рядок 3.
 Структурні змінні, при оголошенні структури, указувати необов'язково, рядок 5.

27.б.) Для чого використовувати структури?
Структури, як правило, використовують тоді, коли в програмі є багато даних
 і їх потрібно згрупувати разом – наприклад, такі дані можуть
 використовуватися для зберігання записів з бази даних.
28.)Оператори в структурі.
Точка оператора "." також використовується і для доступу 
до елементів об'єднання – union. В якості останнього зауваження, 
хочу відзначити такий момент, якщо ви працюєте зі 
структурою через покажчик, то в якості оператора доступу
 до елементів структури потрібно використовувати оператор ->,
 замість оператора ".". 
Все інше залишається актуальним і для покажчиків.

Індексація масиву	a[b]
Розкриття покажчика ("на об'єкт вказує a")	*a
Вказівник ("отримання адреси змінної a")	&а
Розкриття посилання на структуру ("на член b об'єкту вказує a")	a->b
Посилання на структуру ("член b об'єкта a")	a.b

29.) Синтаксис стуктури.
Синтаксис оголошення структури в мові Сі:



1typedef struct name
2{
3    type atrib1;
4    type atrib2;
5    // остальные элементы структуры...
6} newStructName structVar;
Синтаксис оголошення структури в мові Сі припускає два варіанти.
 Перший, опустити ключове слово typedef , при цьому ім'я 
newStructName теж не використовується, і ім'я структури, 
тоді обов'язково необхідно при оголошенні структури використовувати
 структурні змінні – structVar, рядок 6. Дивимося приклад:

1
struct name structVar;
Або ви можете скористатися typedef, для оголошення псевдоніма
 структури newStructName, прізвисько:

1
newStructName structVar;
В будь-якому випадку, якщо ви хочете, оголосити покажчик на структуру 
всередині структури, ви повинні використовувати перший синтаксис:

1
struct name *struct_instance; // указатель на структуру



30. Список ініціалізації(тільки таке )
Инициализация списком
Инициализация списком выполняется, когда переменная инициализируется с 
помощью списка инициализации в фигурных скобках. Списки инициализации в
 фигурных скобках можно использовать в следующих случаях:
Инициализируется переменная.
Инициализируется класс с помощью ключевого слова new.
Объект возвращается функцией.
Аргумент передается функции.
Один из аргументов при прямой инициализации.
В инициализаторе нестатических элементов данных.
В списке инициализации конструктора.
Приведенный ниже код демонстрирует несколько примеров инициализации списком.
VB
class MyClass {  
public:  
    MyClass(int myInt, char myChar) {}    
private:  
    int m_int[]{ 3 };  
    char m_char;  
};  
class MyClassConsumer{  
public:  
    void set_class(MyClass c) {}  
    MyClass get_class() { return MyClass{ 0, '\0' }; }  
};  
struct MyStruct{  
    int my_int;  
    char my_char;  
    MyClass my_class;  
};  
int main() {  
    MyClass mc1{ 1, 'a' };  
    MyClass* mc2 = new MyClass{ 2, 'b' };  
    MyClass mc3 = { 3, 'c' };  
  
    MyClassConsumer mcc;  
    mcc.set_class(MyClass{ 3, 'c' });  
    mcc.set_class({ 4, 'd' });  
  
    MyStruct ms1{ 1, 'a', { 2, 'b' } };  
}  


31. Що таке вказівники?

Грубо кажучи, вказівники - це ті ж самі змінні.
 Однак, їх відмінність від простих змінних полягає в тому,
 що замість фактичних даних вказівник містить адресу комірки пам’яті, 
де знаходиться інформація. Це дуже важливе поняття.
 Багато програм та ідей покладаються на вказівник як основу 
для їх розробки, наприклад, зв'язані списки.
Як нам визначити вказівник? Ну, так само як і інші змінні, за винятком того, що потрібно поставити зірочку перед його ім'ям. Наприклад, наступних два рядки створюють два вказівники на ціле число:

int* pNumberOne;
int* pNumberTwo;

Звернули увагу на префікс "p" в обох іменах змінних? 
Цей прийом використовується для того, щоб показати,
 що змінна є вказівником. Тепер давайте зробимо так,
 щоб вказівники вказували на щось:

pNumberOne = &some_number;
pNumberTwo = &some_other_number;

Знак амперсанд (&) слід розуміти як "адреса чого - небудь", 
він означає, що буде одержана саме адреса змінної у пам'яті, 
а не значення самої змінної. Таким чином, у цьому прикладі,
 у pNumberOne зберігається адреса змінної some_number ,
 тому pNumberOne тепер вказує на some_number.

Тепер, якщо потрібно звернутися за адресою змінної some_number, 
можна використовувати pNumberOne. Для такого звертання слід було
 б написати *pNumberOne. Кажуть, що оператор (*) розіменовує вказівник.
 Це значить, що він повертає значення в комірці пам'яті, на яку вказує 
цей вказівник. За винятком самого оголошення вказівника int *pNumber.


32.)Способи ініціалізації визначника
Існують такі способи ініціалізації вказівника:

1. Присвоювання вказівникові адреси існуючого об'єкта:

a. за допомогою операції взяття адреси:

іnt а = 5; // ціла змінна

іnt *р = &а; // у вказівник р записується адреса змінної а

іnt *р (&а): // те саме іншим способом

· за допомогою значення іншого ініціалізованого вказівника:

іnt *r = р;

· за допомогою імені масиву, що трактується як адреса:

іnt b[10]; // масив

іnt *t = b; // у вказівник t записується адреса початку масиву

· за допомогою імені функції, що трактується як адреса:

voіd f (іnt а ){ /* ... * / } // визначення функції

voіd (*pf) (іnt); // вказівник на функцію

pf = f; // присвоювання адреси функції

2. Присвоювання вказівникові адреси області пам'яті в явному вигляді:

char *vp = (char *) 0хB8000000; // 0хB8000000- шестнадцатеричная константа,

// (char *) - операція приведення типу: константа

// приводиться до типу "вказівник на char"

3. Присвоювання порожнього значення:

іnt *s = NULL;

іnt *rl = 0:

В першому рядку використовується константа NULL.
 Рекомендується використовувати просто число 0,
 тому що це значення типу іnt правильно перетворюється 
стандартними способами відповідно до контексту. 
Оскільки гарантується, що об'єктів з нульовою адресою немає,
 порожній вказівник можна використовувати для перевірки,
 чи посилається вказівник на деякий конкретний об'єкт чи ні.

4. Виділення ділянки динамічної пам'яті і присвоєння
 її адреси вказівникові:

· за допомогою операції new:

іnt *n = new іnt; // 1

іnt *k = new іnt (10); // 2

іnt *q = new іnt [10]; // 3

· за допомогою функції malloc:

іnt *u = (іnt *) malloc(sizeof(іnt)); // 4
33.)
Динамічні змінні
Динамічні змінні не мають імен. 
Вони розташовуються в динамічній пам'яті, чи купі, і видаляються 
з неї під час виконання програми. Для звертання до цих змінних потрібні 
особливі засоби: вказівники і посилання. Динамічні змінні створюються 
або оператором new, або стандартною функцією (malloc(), calloc() чи realloc()).
 Знищення динамічних змінних здійснюється оператором delete (після того,
 як пам’ять була виділена оператором new) чи функцією free()
 (при використанні разом з ним функцій malloc() , calloc() чи realloc()).
 Оператор виділення пам'яті new як операнд використовує ім'я типу.
 Результатом цього оператора є вказівник на адресу динамічної області пам’яті,
 що має тип операнда. Динамічна змінна зв'язується з типом під час іляції,
 тому це зв'язування є статичним. Втім, динамічні змінні зв'язуються з 
виділеною областю пам'яті в ході виконання програми, тому цей вид зв'язування
 є динамічним.
34.я)як створити і видалити одновимірний динамічний масив?
В С операції new і delete призначені для динамічного розподілу пам'яті
 комп'ютера. Операція new виділяє пам'ять з області вільної пам'яті,
 а операція delete вивільняє виділену пам'ять. 
Виділювана пам'ять, після її використання повинна вивільнятися,
 тому операції new і delete використовуються парами.
 Навіть якщо не вивільняти пам'ять явно, то вона звільниться ресурсами ОС 
по завершенню роботи програми. Рекомендую все-таки не забувати про 
операцію delete.
35.)Створюємо одновимірний маств і в циклі перебираємо елементи ,
які потрібно вивести або ввести.






